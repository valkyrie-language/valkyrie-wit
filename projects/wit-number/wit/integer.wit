package vit:number



interface natural {
    /// unsigned integer buffer
    resource natural {
        constructor(init: list<u32>);
        zero: static func() -> natural
        one: static func() -> natural

        add-u32: func(rhs: u32) -> natural
        add-u64: func(rhs: u64) -> natural
        add-nat: func(rhs: borrow<natural>) -> natural

        iter-has-next: func(self: borrow<natural>) -> bool
        iter-has-prev: func(self: borrow<natural>) -> bool
        iter-next: func(self: borrow<natural>) -> option<natural>
        iter-prev: func(self: borrow<natural>) -> option<natural>
    }
}

interface integer {
    use natural.{natural};
    enum sign {
        un-sign,
        positive,
        negative
    }
    record integer {
        sign: sign,
        natural: natural
    }
    // %[method] integer.add-u32
    // add area
    add-u32: func(self: integer, rhs: u32) -> integer;
    add-u64: func(self: integer, rhs: u64) -> integer;
    add-nat: func(self: integer, rhs: borrow<natural>) -> integer;
    add-i32: func(self: integer, rhs: s32) -> integer;
    add-i64: func(self: integer, rhs: s64) -> integer;
    add-int: func(self: integer, rhs: integer) -> integer;
    // sub area
    sub-u32: func(self: integer, rhs: u32) -> integer;
    sub-u64: func(self: integer, rhs: u64) -> integer;
    sub-nat: func(self: integer, rhs: borrow<natural>) -> integer;
    sub-i32: func(self: integer, rhs: s32) -> integer;
    sub-i64: func(self: integer, rhs: s64) -> integer;
    sub-int: func(self: integer, rhs: integer) -> integer;
}

interface ordinal {
    record ordinal {
        natural: natural
    }
}

world integer-ffi {
    export natural
    export integer
    export ordinal
}
